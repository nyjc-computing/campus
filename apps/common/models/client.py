"""apps.common.models.client

This module provides classes and utilities for handling client applications
and API keys for Campus services.
"""
import os
from typing import NotRequired, TypedDict, Unpack

from apps.common.errors import api_errors
from apps.common.models.base import BaseRecord
from common.utils import secret, uid, utc_time
from storage import get_table

APIName = str
APIKey = str
Email = str

TABLE = "clients"


def init_db() -> None:
    """Initialize the tables needed by the model.

    This function is intended to be called only in a test environment (using a
    local-only db like SQLite), or in a staging environment before upgrading to
    production.
    """
    storage = get_table(TABLE)
    schema = f"""
        CREATE TABLE IF NOT EXISTS "{TABLE}" (
            id TEXT PRIMARY KEY,
            secret_hash TEXT,
            name TEXT NOT NULL,
            description TEXT,
            created_at TEXT NOT NULL,
            UNIQUE (name),
            UNIQUE (secret_hash)
        );
    """
    storage.init_table(schema)
    
    # TODO: Implement API keys table when needed
    # apikey_schema = """
    #     CREATE TABLE IF NOT EXISTS apikeys (
    #         client_id TEXT NOT NULL,
    #         name TEXT NOT NULL,
    #         key TEXT NOT NULL,
    #         PRIMARY KEY (client_id, name),
    #         UNIQUE (key),
    #         FOREIGN KEY (client_id) REFERENCES clients(client_id) ON DELETE CASCADE
    #     )
    # """
    # apikey_storage = get_table("apikeys")
    # apikey_storage.init_table(apikey_schema)


class ClientNew(TypedDict, total=True):
    """Request body schema for a clients.new operation."""
    name: str
    description: str


class ClientUpdate(TypedDict, total=False):
    """Request body schema for a clients.update operation."""
    name: str
    description: str


class ClientResource(ClientNew, BaseRecord, total=True):
    """Response body schema representing the result of a clients.get operation.
    """
    # secret_hash is generated by developer manually and not at creation time
    secret_hash: NotRequired[str]
    # apikeys: NotRequired[dict[APIName, APIKey]]
    # admins: list[Email]


class ClientReplaceResponse(TypedDict, total=True):
    """Response body schema for a clients.replace operation."""
    secret: str


class Client:
    """Model for database operations related to client applications."""
    # Nested attribute follows Campus API schema
    # apikeys = ClientAPIKey()

    def __init__(self):
        """Initialize the Client model with a table storage interface."""
        self.storage = get_table(TABLE)

    def delete(self, client_id: str) -> None:
        """Delete a client application by its ID."""
        # Check if client exists first
        client = self.storage.get_by_id(client_id)
        if not client:
            raise api_errors.ConflictError(
                "Client not found",
                client_id=client_id
            )
        try:
            self.storage.delete_by_id(client_id)
        except Exception as e:
            raise api_errors.InternalError(message=str(e), error=e)

    def list(self) -> list:
        """List all client applications."""
        try:
            # Table interface doesn't have get_all, but get_matching with empty query
            # should return all records. Let's use get_matching with empty dict.
            results = self.storage.get_matching({})
            return results
        except Exception as e:
            raise api_errors.InternalError(message=str(e), error=e)

    def get(self, client_id: str) -> ClientResource:
        """Retrieve a client application by its ID, including its admins."""
        try:
            client_record = self.storage.get_by_id(client_id)
            if not client_record:
                raise api_errors.ConflictError(
                    "Client not found",
                    client_id=client_id
                )
            
            # Do not reveal secrets in API - make a copy first
            client_data = dict(client_record)
            if "secret_hash" in client_data:
                del client_data["secret_hash"]
            return client_data  # type: ignore
        except api_errors.ConflictError:
            raise
        except Exception as e:
            raise api_errors.InternalError(message=str(e), error=e)

    def new(self, **fields: Unpack[ClientNew]) -> ClientResource:
        """Create a new client."""
        # Use Client model to validate keyword arguments
        client_id = uid.generate_category_uid("client", length=8)
        record = dict(
            id=client_id,
            created_at=utc_time.now(),
            **fields,
        )
        try:
            self.storage.insert_one(record)
            return record  # type: ignore
        except Exception as e:
            raise api_errors.InternalError(message=str(e), error=e)

    def replace(self, client_id: str) -> dict[str, str]:
        """Revoke a client secret by its ID, and issue a new secret."""
        # Check if client exists first
        client = self.storage.get_by_id(client_id)
        if not client:
            raise api_errors.ConflictError(
                "Client not found",
                client_id=client_id
            )
        
        client_secret = secret.generate_client_secret()
        try:
            self.storage.update_by_id(
                client_id,
                {"secret_hash": secret.hash_client_secret(
                    client_secret,
                    os.environ["SECRET_KEY"]
                )}
            )
            return {"secret": client_secret}
        except Exception as e:
            raise api_errors.InternalError(message=str(e), error=e)

    def update(self, client_id: str, **updates: Unpack[ClientNew]) -> None:
        """Update an existing client record."""
        if not updates:
            return

        # Check if client exists first
        client = self.storage.get_by_id(client_id)
        if not client:
            raise api_errors.ConflictError(
                "Client not found",
                client_id=client_id
            )
        
        try:
            self.storage.update_by_id(client_id, dict(updates))
        except Exception as e:
            raise api_errors.InternalError(message=str(e), error=e)

    def validate_credentials(
            self,
            client_id: str,
            client_secret: str
    ) -> None:
        """Validate client_id and client_secret.
        
        Raises:
            api_errors.InternalError: Error retrieving the stored credentials.
            api_errors.ForbiddenError: Client is not found or secret is invalid.
        """
        try:
            client = self.storage.get_by_id(client_id)
            if not client:
                api_errors.raise_api_error(
                    403, message="Client not found", client_id=client_id)
            
            secret_hash = secret.hash_client_secret(
                client_secret, os.environ["SECRET_KEY"]
            )
            if client["secret_hash"] != secret_hash:
                api_errors.raise_api_error(
                    403,
                    message="Invalid client secret",
                    client_id=client_id
                )
        except Exception as e:
            if isinstance(e, type(api_errors.APIError)) and hasattr(e, 'status_code'):
                raise  # Re-raise API errors as-is
            raise api_errors.InternalError(message=str(e), error=e)
