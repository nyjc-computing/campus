"""
Client Models

This module provides classes and utilities for handling client applications
and API keys for Campus services.
"""
import os
from typing import NotRequired, TypedDict, Unpack

from apps.common.errors import api_errors
from apps.api.models.base import BaseRecord, ModelResponse
from common import devops
from common.drum import DrumResponse
from common.schema import Message, Response
from common.utils import secret, uid, utc_time

if devops.ENV in (devops.STAGING, devops.PRODUCTION):
    from common.drum.postgres import get_conn, get_drum
else:
    from common.drum.sqlite import get_conn, get_drum

APIName = str
APIKey = str
Email = str

TABLE = "clients"


def init_db() -> None:
    """Initialize the tables needed by the model.

    This function is intended to be called only in a test environment (using a
    local-only db like SQLite), or in a staging environment before upgrading to
    production.
    """
    # TODO: Refactor into decorator
    if os.getenv('ENV', 'development') == 'production':
        raise AssertionError(
            "Database initialization detected in production environment"
        )
    conn = get_conn()
    try:
        cursor = conn.cursor()
        cursor.execute("""
            CREATE TABLE IF NOT EXISTS "clients" (
                id TEXT PRIMARY KEY,
                secret_hash TEXT,
                name TEXT NOT NULL,
                description TEXT,
                created_at TEXT NOT NULL,
                UNIQUE (name),
                UNIQUE (secret_hash)
            );
        """)
        # cursor.execute("""
        #     CREATE TABLE IF NOT EXISTS apikeys (
        #         client_id TEXT NOT NULL,
        #         name TEXT NOT NULL,
        #         key TEXT NOT NULL,
        #         PRIMARY KEY (client_id, name),
        #         UNIQUE (key),
        #         FOREIGN KEY (client_id) REFERENCES clients(client_id) ON DELETE CASCADE
        #     )
        # """)
    except Exception:  # pylint: disable=try-except-raise
        # init_db() is not expected to be called in production, so we don't
        # need to handle errors gracefully.
        raise
    else:
        conn.commit()
    finally:
        conn.close()


class ClientNew(TypedDict, total=True):
    """Request body schema for a clients.new operation."""
    name: str
    description: str


class ClientUpdate(TypedDict, total=False):
    """Request body schema for a clients.update operation."""
    name: str
    description: str


class ClientResource(ClientNew, BaseRecord, total=True):
    """Response body schema representing the result of a clients.get operation.
    """
    # secret_hash is generated by developer manually and not at creation time
    secret_hash: NotRequired[str]
    # apikeys: NotRequired[dict[APIName, APIKey]]
    # admins: list[Email]


class ClientReplaceResponse(TypedDict, total=True):
    """Response body schema for a clients.replace operation."""
    secret: str


class Client:
    """Model for database operations related to client applications."""
    # Nested attribute follows Campus API schema
    # apikeys = ClientAPIKey()

    def __init__(self):
        """Initialize the Client model with a storage interface."""
        self.storage = get_drum()

    def delete(self, client_id: str) -> ModelResponse:
        """Delete a client application by its ID."""
        resp = self.storage.delete_by_id(TABLE, client_id)
        match resp:
            case Response(status="error", message=message, data=error):
                raise api_errors.InternalError(message=message, error=error)
            case Response(status="ok", message=Message.NOT_FOUND):
                raise api_errors.ConflictError(
                    "Client not found",
                     client_id=client_id
                )
            case Response(status="ok", message=Message.DELETED, data=data):
                return ModelResponse("ok", Message.DELETED, data)
        raise ValueError(f"Unexpected response: {resp}")

    def list(self) -> ModelResponse:
        """List all client applications."""
        resp = self.storage.get_all(TABLE)
        match resp:
            case Response(status="error", message=message, data=error):
                raise api_errors.InternalError(message=message, error=error)
            case Response(status="ok", message=Message.FOUND, data=result):
                return ModelResponse("ok", Message.FOUND, result)
            case Response(status="ok", message=Message.EMPTY):
                return ModelResponse("ok", Message.EMPTY, [])
        raise ValueError(f"Unexpected response: {resp}")

    def get(self, client_id: str) -> ModelResponse:
        """Retrieve a client application by its ID, including its admins."""
        resp = self.storage.get_by_id(TABLE, client_id)
        match resp:
            case Response(status="error", message=message, data=error):
                raise api_errors.InternalError(message=message, error=error)
            case Response(status="ok", message=Message.NOT_FOUND, data=None):
                raise api_errors.ConflictError(
                    "Client not found",
                     client_id=client_id
                )
        assert isinstance(resp, DrumResponse)  # appease mypy
        client_record = resp.data
        # Do not reveal secrets in API
        del client_record["secret_hash"]
        return ModelResponse("ok", Message.SUCCESS, client_record)

    def new(self, **fields: Unpack[ClientNew]) -> ModelResponse:
        """Create a new client."""
        # Use Client model to validate keyword arguments
        client_id = uid.generate_category_uid("client", length=8)
        record = ClientResource(
            id=client_id,
            created_at=utc_time.now(),
            **fields,
        )
        resp = self.storage.insert(TABLE, record)
        match resp:
            case Response(status="error", message=message, data=error):
                raise api_errors.InternalError(message=message, error=error)
            case Response(status="ok", message=Message.SUCCESS, data=result):
                return ModelResponse("ok", Message.CREATED, result)
        raise ValueError(f"Unexpected response: {resp}")

    def replace(self, client_id: str) -> ModelResponse:
        """Revoke a client secret by its ID, and issue a new secret."""
        client_secret = secret.generate_client_secret()
        resp = self.storage.update_by_id(
            TABLE,
            client_id,
            {"secret_hash": secret.hash_client_secret(
                client_secret,
                os.environ["SECRET_KEY"]
            )}
        )
        match resp:
            case Response(status="error", message=message, data=error):
                raise api_errors.InternalError(message=message, error=error)
            case Response(status="ok", message=Message.NOT_FOUND):
                raise api_errors.ConflictError(
                    "Client not found",
                     client_id=client_id
                )
            case Response(status="ok", message=Message.UPDATED):
                return ModelResponse("ok", Message.SUCCESS, {
                    "secret": client_secret
                })
        raise ValueError(f"Unexpected response: {resp}")

    def update(self, client_id: str, **updates: Unpack[ClientNew]) -> ModelResponse:
        """Update an existing client record."""
        if not updates:
            return ModelResponse("ok", Message.EMPTY, "Nothing to update")
        
        resp = self.storage.update_by_id(TABLE, client_id, updates)
        match resp:
            case Response(status="error", message=message, data=error):
                raise api_errors.InternalError(message=message, error=error)
            case Response(status="ok", message=Message.NOT_FOUND):
                raise api_errors.ConflictError(
                    "Client not found",
                     client_id=client_id
                )
            case Response(status="ok", message=Message.UPDATED):
                return ModelResponse("ok", Message.UPDATED)
        raise ValueError(f"Unexpected response: {resp}")

    def validate_credentials(self, client_id: str, client_secret: str) -> None:
        """Validate client_id and client_secret."""
        resp = self.storage.get_by_id(TABLE, client_id)
        match resp:
            case Response(status="error", message=message, data=error):
                raise api_errors.InternalError(message=message, error=error)
            case Response(status="ok", message=Message.NOT_FOUND):
                api_errors.raise_api_error(403, message="Client not found", client_id=client_id)
            case Response(status="ok", message=Message.FOUND, data=cursor):
                client = cursor['result']
                secret_hash = secret.hash_client_secret(
                    client_secret, os.environ["SECRET_KEY"]
                )
                if client["secret_hash"] != secret_hash:
                    api_errors.raise_api_error(
                        403,
                        message="Invalid client secret",
                        client_id=client_id
                    )
        raise ValueError(f"Unexpected response: {resp}")


# class APIKeyNewSchema(TypedDict):
#     """Data model for a clients.apikeys.new operation."""
#     name: APIName
#     description: str


# class APIKeyRecord(TypedDict):
#     """Data model for an API key."""
#     client_id: str
#     name: APIName
#     key: APIKey


# class ClientAPIKey:
#     """Model for database operations related to client API keys."""

#     def __init__(self):
#         self.storage = get_drum()

#     def new(self, client_id: str, *, name: str) -> ModelResponse:
#         """Create a new API key for a client.

#         Validate name first before calling this function.

#         Args:
#             client_id: The ID of the client.
#             name: The name of the API key.

#         Returns:
#             A ModelResponse indicating the result of the operation.
#         """
#         if not validname.is_valid_label(name):
#             raise api_errors.InvalidRequestError(
#                 message="Invalid API key name",
#                 invalid_values=["name"]
#             )
#         api_key = secret.generate_api_key()
#         record = APIKeyRecord(
#             client_id=client_id,
#             name=name,
#             key=api_key
#         )
#         resp = self.storage.insert("apikeys", record)
#         match resp:
#             case Response(status="error", message=message, data=error):
#                 raise api_errors.InternalError(message=message, error=error)
#             case Response(status="ok", message=Message.CREATED):
#                 return ModelResponse("ok", "API key created", record["key"])
#         raise ValueError(f"Unexpected response: {resp}")

#     def list(self, client_id: str) -> ModelResponse:
#         """Retrieve all API keys for a client."""
#         resp = self.storage.get_matching("apikeys", {"client_id": client_id})
#         match resp:
#             case Response(status="error", message=message, data=error):
#                 raise api_errors.InternalError(message=message, error=error)
#             case Response(status="ok", message=Message.FOUND, data=result):
#                 return ModelResponse("ok", Message.SUCCESS, result)
#             case Response(status="ok", message=Message.EMPTY):
#                 return ModelResponse("ok", Message.EMPTY, [])
#         raise ValueError(f"Unexpected response: {resp}")

#     def delete(self, client_id: str, name: str) -> ModelResponse:
#         """Delete an API key for a client."""
#         resp = self.storage.delete_matching(
#             "apikeys",
#             {"client_id": client_id, "name": name}
#         )
#         match resp:
#             case Response(status="error", message=message, data=error):
#                 raise api_errors.InternalError(message=message, error=error)
#             case Response(status="ok", message=Message.NOT_FOUND):
#                 raise api_errors.ConflictError(
#                     "API key not found",
#                      client_id=client_id, name=name
#                 )
#             case Response(status="ok", message=Message.DELETED):
#                 return ModelResponse(*resp)
#         raise ValueError(f"Unexpected response: {resp}")
